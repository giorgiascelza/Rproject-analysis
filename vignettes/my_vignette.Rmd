---
title: "Rproject: A Complete Workflow for Single-Cell Multi-Omic Analysis"
author: "Giorgia Scelza"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Rproject: A Complete Workflow for Single-Cell Multi-Omic Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = TRUE, message = TRUE)
library(Rproject)
```

# Project Overview

This document serves as a vignette for the Rproject package, an R library developed to streamline the analysis of 10x Genomics single-cell multi-omic (gene expression + ATAC-seq) data. The primary goal is to provide a reproducible and modular workflow, from raw data loading to final visualization. We will process both the gene expression and chromatin accessibility data to explore the relationship between chromatin state and gene regulation. The entire project is encapsulated in a Docker container to ensure complete reproducibility of the environment and the analysis.

# Reproducibility: Docker Environment

To guarantee that this analysis can be run on any machine, a Docker container was created. The container is based on ubuntu:20.04 and includes R, all required system dependencies, and the specific R packages (Seurat, Signac, BiocManager, etc.) needed for the analysis.

**Docker Hub:** The final image is available on Docker Hub and can be pulled using the following command:

``` bash
# To be replaced with your actual Docker Hub username
docker pull your-dockerhub-username/image-seurat-signac:latest
```

## Replicating the Analysis

To replicate this analysis, follow these steps:

1.  **Run the Docker Container**:

`bash     # Mount a local directory to retrieve the results     docker run -it -v "/path/to/your/local/folder:/results" your-dockerhub-username/image-seurat-signac`

2.  **Execute the Vignette in R**: Inside the container's R session, this report can be regenerated. `R     # This command will re-run the analysis and save the HTML report     # to the mounted /results directory.     rmarkdown::render(       "/path/in/container/to/Rproject/vignettes/my_vignette.Rmd",        output_dir = "/results"     )`

# Problems Encountered and Solutions

This section describes the technical challenges faced during development and the strategies used to overcome them. During the package development, several common but critical issues were encountered:

1.  Package installation and Rtools: The initial R CMD check failed because the necessary build tools (Rtools) were not installed or were of an incompatible version. Solution: The correct version of Rtools (Rtools45) was installed, and the system PATH was configured via the .Renviron file to ensure R could find the compilers.

2.  Dependency Management in NAMESPACE: The primary challenge was correctly declaring dependencies for Bioconductor's S4 methods (counts, rowData, etc.). Initial attempts using @importFrom failed because these generic functions are not formally exported from their implementation packages. Solution: The NAMESPACE was stabilized by importing the packages that define these generics (BiocGenerics, S4Vectors, SummarizedExperiment) in their entirety using @import. This resolved all "could not find function" errors during the check.

3.  data.table and ggplot2 Global Variables: R CMD check issued NOTEs for "no visible binding for global variable" for terms like ., feature, and seqnames. Solution: A file R/globals.R was created with a utils::globalVariables() call to explicitly declare these terms, silencing the NOTEs.

``` r
utils::globalVariables(c(".", "feature", "gene_id", "norm_peak_signal", "atac_cpm", "seqnames", "total_accessibility", "expression_cpm"))
```

# Full Analysis Workflow

This section demonstrates the use of the Rproject package to perform the end-to-end analysis. The workflow is executed by calling the exported functions in sequence.

-   **Setup: Defining Paths**\
    First, we define the paths to the input data and the output directory. For this report, we will use the example data included within the package itself.

```{r setup_paths, echo=TRUE, message=TRUE, warning=TRUE}
example_data_dir <- system.file("extdata", "mini_pbmc3k", package = "Rproject")
example_gtf_path <- system.file("extdata", "mini_annotation.gtf.gz", package = "Rproject")
output_dir <- file.path(tempdir(), "analysis_results")
if (!dir.exists(output_dir)) {
  dir.create(output_dir)
}
cat("Using example data from:", example_data_dir, "\n")
cat("Saving results to:", output_dir, "\n")
```

-   **Step 1: Load and Convert Matrix** The analysis starts by loading the raw data from the 10x Genomics output folder. The `load_and_convert_matrix()` function reads the sparse matrix (`matrix.mtx.gz`) and its corresponding feature and barcode annotations. It converts the sparse matrix into a dense `data.table` object, which is efficient for subsequent manipulations.

```{r step_1, echo=TRUE, message=TRUE, warning=TRUE}
dt_matrix <- load_and_convert_matrix(data_folder = example_data_dir)
```

-   **Step 2: Split Data** From the combined `data.table`, we separate the gene expression data from the ATAC-seq peak data. This is done by identifying rows based on their feature names: Ensembl gene IDs (e.g., `ENSG...`) for expression, and genomic coordinates (e.g., `chr1:123-456`) for peaks.

```{r step_2, echo=TRUE, message=TRUE, warning=TRUE}
data_list <- split_data(dt_matrix = dt_matrix)
```

-   **Step 3: Summarize Features** For each dataset, we compute a summary metric across all cells. Here, we calculate the total counts for each gene and the total accessibility for each peak region. This reduces the dimensionality of the data to a single vector per modality, representing the overall signal for each feature.

```{r step_3, echo=TRUE, message=TRUE, warning=TRUE}
summary_list <- summarize_data(data_list = data_list)
```

-   **Step 4: Create GenomicRanges** To perform genomic coordinate-based operations, we convert our summarized data into `GRanges` objects. This data structure, from the `GenomicRanges` package, is ideal for handling genomic data. The summarized counts from Step 3 are stored as metadata within these objects.

```{r step_4, echo=TRUE, message=TRUE, warning=TRUE}
granges_list <- create_granges_objects(
  summary_list = summary_list,
  gtf_file_path = example_gtf_path
)
```

In these steps, we link the ATAC-seq peaks to genes. 1. **Gene Annotation:** We first create a `GRanges` object containing only protein-coding genes from the provided GTF annotation file. 2. **Peak Mapping:** We find overlaps between the ATAC peaks and these gene annotations. 3. **Finalize Expression Data:** We subset the expression data to include only the same set of protein-coding genes, ensuring consistency between the two modalities. Gene symbols are also added for better readability.

-   **Step 5: Map Peaks to Genes**

```{r step_5, echo=TRUE, message=TRUE, warning=TRUE}
mapping_list <- map_peaks_to_genes(granges_list = granges_list)
```

-   **Step 6: Finalize Expression Data**

```{r step_6, echo=TRUE, message=TRUE, warning=TRUE}
gr_expr_pc <- finalize_expression_data(mapping_list = mapping_list)
```

-   **Step 7: Normalize and Integrate** This is a critical step where both datasets are normalized to account for differences in sequencing depth per cell. We use the **Counts Per Million (CPM)** method, followed by a log2 transformation. After normalization, we aggregate the ATAC signals based on the gene mappings from the previous step and merge the two datasets. We also generate summaries and plots for features that could not be integrated.

```{r step_7, echo=TRUE, message=TRUE, warning=TRUE}
annotated_list <- list(
  gr_expr_pc = gr_expr_pc,
  gr_peaks = granges_list$gr_peaks,
  overlaps = mapping_list$overlaps
)

step7_results <- normalize_and_integrate(
  data_list = data_list,
  annotated_list = annotated_list
)
```

**Interpretation:** The summary tables indicate the number of peaks and genes that were successfully integrated. The boxplots visualize the signal distribution for the unmerged features, providing insight into why they may not have been mapped. For instance, unmapped peaks might be weak or located in intergenic regions, while genes without ATAC signals might be silenced or regulated by distal elements not captured by our simple overlap-based mapping.

-   **Step 8: Visualize and Save** The final step is to visualize the relationship between gene expression and chromatin accessibility for the successfully integrated genes. We generate a scatter plot where each point is a gene. Given the large number of data points, the plot is faceted by chromosome for clarity. All results, including plots and tables, are saved to the output directory.

```{r step_8, echo=TRUE, message=TRUE, warning=TRUE}
visualize_and_save(
  step7_results = step7_results,
  output_folder = output_dir
)
```

**Interpretation:** The final scatter plots, faceted by chromosome, illustrate the correlation between a gene's expression level and the accessibility of its associated chromatin regions. A general positive trend, where higher accessibility corresponds to higher expression, would support the biological hypothesis that open chromatin is a prerequisite for active transcription. Deviations from this trend can highlight genes under more complex regulatory control.

# Conclusion

The `Rproject` package successfully provides a structured, reproducible, and robust workflow for the integrated analysis of single-cell multi-omic data. By encapsulating the logic in a modular package and ensuring environmental consistency with Docker, this project establishes a reliable foundation for complex bioinformatics analyses. The entire pipeline, from raw data to final plots, can be executed seamlessly, as demonstrated in this vignette.
